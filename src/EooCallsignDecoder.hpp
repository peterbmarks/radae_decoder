/**
 * EooCallsignDecoder.hpp
 *
 * Self-contained C++ class that decodes the operator callsign embedded in a
 * RADE End-of-Over (EOO) float symbol buffer.
 *
 * All required codec2 logic is inlined here:
 *   - HRA_56_56 LDPC(112,56) parity matrix
 *   - Golden-prime deinterleaver (N=56, b=37)
 *   - phi0 lookup table
 *   - QPSK soft demodulator (Demod2D / Somap)
 *   - Sum-product belief-propagation LDPC decoder
 *   - rade_text CRC-8 and 6-bit OTA character mapping
 *
 * No external dependencies beyond standard C++ headers.
 *
 * Usage:
 *   EooCallsignDecoder dec;
 *   std::string callsign;
 *   if (dec.decode(eooOut, rade_n_eoo_bits(dv) / 2, callsign))
 *       std::cout << callsign << "\n";
 *
 * Provenance / License:
 *   Derived from codec2 1.2.0 (David Rowe et al.) and FreeDV GUI
 *   (Mooneer Salem et al.), both licensed under the GNU LGPL v2.1.
 *   This combined file is therefore also released under the LGPL v2.1.
 *   See <https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html>.
 */

#pragma once

#include <cassert>
#include <cmath>
#include <cstdint>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <string>

// ============================================================================
// Internal implementation – anonymous namespace so nothing leaks into the
// including translation unit.
// ============================================================================
namespace {

// ---------------------------------------------------------------------------
// 1. Complex float type  (codec2/src/comp.h)
// ---------------------------------------------------------------------------
struct EooComp { float real, imag; };

// ---------------------------------------------------------------------------
// 2. HRA_56_56 parity-check matrix  (codec2/src/HRA_56_56.c)
//
//    Rate-1/2 LDPC(112,56): 56 information bits + 56 parity bits.
//    Used by FreeDV 700E and RADE End-of-Over.
//
//    H_rows: 56 rows × 3 columns (max_row_weight = 3), stored column-major
//             so index into row i, column j = H_rows[i + j*56].
//    H_cols: 56 rows × 3 columns (max_col_weight = 3), same layout.
//    Non-zero entries are 1-based variable-node indices.
// ---------------------------------------------------------------------------
static const uint16_t kHra5656Rows[] = {
     4,  33,  22,   2,   7,  12,  15,  41,   6,   2,   8,   4,   1,   7,
    20,  10,   2,   1,  28,   7,   3,  25,  18,  19,  17,  15,   8,  13,
     9,  12,  39,   6,  17,  32,   3,   6,  10,  18,   4,  34,   1,  14,
     9,   5,  15,  12,   5,  35,   5,  17,  16,  36,  20,   9,  34,  33,
    14,  46,  39,  27,  43,  22,  19,  45,  16,  23,  31,  52,   3,   8,
    51,  13,  31,  11,  31,  36,  11,  28,  30,  21,  38,  26,  42,  29,
    23,  33,  45,  19,  28,  40,  10,  23,  41,  25,  29,  36,  29,  49,
    38,  11,  30,  42,  16,  37,  49,  35,  18,  47,  24,  25,  54,  34,
    41,  55,  47,  44,  56,  46,  20,  55,  21,  40,  37,  53,  13,  32,
    52,  22,  32,  24,  44,  42,  49,  38,  48,  24,  56,  48,  50,  39,
    26,  50,  54,  26,  37,  56,  14,  27,  46,  44,  45,  43,  53,  52,
    40,  21,  51,  47,  30,  50,  51,  43,  27,  54,  53,  48,  55,  35
};

static const uint16_t kHra5656Cols[] = {
    13,   4,  13,   1,  44,   9,   5,  11,  29,  16,  18,   6,  13,   1,
     7,   9,  25,  23,   7,   7,   9,   3,  10,  18,  22,  26,   4,  19,
    28,  23,  11,  14,   2,  40,  48,  20,  11,  22,   3,  10,   1,  20,
     5,   4,   8,   2,   3,  23,  21,  27,  15,  12,  12,  31,   2,   5,
    18,  10,  21,  12,  47,  32,  14,  14,  43,  35,  21,  30,  16,  35,
    26,  47,  33,  38,  24,  15,  24,   6,  29,  24,  38,  29,  36,  22,
    39,  45,  17,  17,  30,  55,  50,  40,  33,  25,  28,  34,   8,  27,
    40,  19,  31,   6,  46,  26,  42,  30,  45,  15,  41,  52,   8,  25,
    41,  17,  35,  39,  49,  36,  20,  27,  54,  37,  44,  46,  28,  42,
    45,  51,  50,  51,  32,  53,  44,  16,  36,  53,  54,  32,  51,  33,
    41,  47,  19,  34,  56,  56,  56,  52,  48,  43,  31,  43,  37,  46,
    50,  38,  39,  37,  52,  54,  49,  48,  49,  42,  53,  55,  55,  34
};

// HRA_56_56 parameters (from HRA_56_56.h)
static const int kCodeLength       = 112;
static const int kNumParityBits    = 56;
static const int kNumRowsHcols     = 56;
static const int kMaxRowWeight     = 3;
static const int kMaxColWeight     = 3;
static const int kMaxIter          = 100;
static const int kDecType          = 0;   // uses phi0, not |LLR|

// ---------------------------------------------------------------------------
// 3. phi0 lookup table  (codec2/src/phi0.c)
//
//    Approximates phi(x) = log((exp(x)+1)/(exp(x)-1)), the Gallager function
//    used by the sum-product LDPC decoder.  Generated by gen_phi0 scripts.
// ---------------------------------------------------------------------------
static float eoo_phi0(float xf)
{
    // SI16: scale float to fixed-point Q16
    const int32_t x = static_cast<int32_t>(xf * 65536.0f);

    if (x >= static_cast<int32_t>(10.0f * 65536.0f)) return 0.0f;

    if (x >= static_cast<int32_t>(5.0f * 65536.0f)) {
        // Coarse table: 0.5-unit steps from 5.0 to 9.5
        switch (19 - (x >> 15)) {
            case 0: return 0.000116589f;   // 9.5
            case 1: return 0.000192223f;   // 9.0
            case 2: return 0.000316923f;   // 8.5
            case 3: return 0.000522517f;   // 8.0
            case 4: return 0.000861485f;   // 7.5
            case 5: return 0.001420349f;   // 7.0
            case 6: return 0.002341760f;   // 6.5
            case 7: return 0.003860913f;   // 6.0
            case 8: return 0.006365583f;   // 5.5
            case 9: return 0.010495133f;   // 5.0
        }
    } else if (x >= static_cast<int32_t>(1.0f * 65536.0f)) {
        // Fine table: 0.0625-unit steps from 1.0 to 4.9375
        switch (79 - (x >> 12)) {
            case  0: return 0.013903889f;
            case  1: return 0.014800644f;
            case  2: return 0.015755242f;
            case  3: return 0.016771414f;
            case  4: return 0.017853133f;
            case  5: return 0.019004629f;
            case  6: return 0.020230403f;
            case  7: return 0.021535250f;
            case  8: return 0.022924272f;
            case  9: return 0.024402903f;
            case 10: return 0.025976926f;
            case 11: return 0.027652501f;
            case 12: return 0.029436184f;
            case 13: return 0.031334956f;
            case 14: return 0.033356250f;
            case 15: return 0.035507982f;
            case 16: return 0.037798579f;
            case 17: return 0.040237016f;
            case 18: return 0.042832850f;
            case 19: return 0.045596260f;
            case 20: return 0.048538086f;
            case 21: return 0.051669874f;
            case 22: return 0.055003924f;
            case 23: return 0.058553339f;
            case 24: return 0.062332076f;
            case 25: return 0.066355011f;
            case 26: return 0.070637993f;
            case 27: return 0.075197917f;
            case 28: return 0.080052790f;
            case 29: return 0.085221814f;
            case 30: return 0.090725463f;
            case 31: return 0.096585578f;
            case 32: return 0.102825462f;
            case 33: return 0.109469985f;
            case 34: return 0.116545700f;
            case 35: return 0.124080967f;
            case 36: return 0.132106091f;
            case 37: return 0.140653466f;
            case 38: return 0.149757747f;
            case 39: return 0.159456024f;
            case 40: return 0.169788027f;
            case 41: return 0.180796343f;
            case 42: return 0.192526667f;
            case 43: return 0.205028078f;
            case 44: return 0.218353351f;
            case 45: return 0.232559308f;
            case 46: return 0.247707218f;
            case 47: return 0.263863255f;
            case 48: return 0.281099022f;
            case 49: return 0.299492155f;
            case 50: return 0.319127030f;
            case 51: return 0.340095582f;
            case 52: return 0.362498271f;
            case 53: return 0.386445235f;
            case 54: return 0.412057648f;
            case 55: return 0.439469363f;
            case 56: return 0.468828902f;
            case 57: return 0.500301872f;
            case 58: return 0.534073947f;
            case 59: return 0.570354566f;
            case 60: return 0.609381573f;
            case 61: return 0.651427083f;
            case 62: return 0.696805010f;
            case 63: return 0.745880827f;
        }
    } else {
        // Sub-unit range: nested binary search
        if (x > static_cast<int32_t>(0.007812f * 65536.0f)) {
            if (x > static_cast<int32_t>(0.088388f * 65536.0f)) {
                if (x > static_cast<int32_t>(0.250000f * 65536.0f)) {
                    if (x > static_cast<int32_t>(0.500000f * 65536.0f))
                        return x > static_cast<int32_t>(0.707107f * 65536.0f) ? 0.922449644f : 1.241248638f;
                    else
                        return x > static_cast<int32_t>(0.353553f * 65536.0f) ? 1.573515241f : 1.912825912f;
                } else {
                    if (x > static_cast<int32_t>(0.125000f * 65536.0f))
                        return x > static_cast<int32_t>(0.176777f * 65536.0f) ? 2.255740095f : 2.600476919f;
                    else
                        return 2.946130351f;
                }
            } else {
                if (x > static_cast<int32_t>(0.022097f * 65536.0f)) {
                    if (x > static_cast<int32_t>(0.044194f * 65536.0f))
                        return x > static_cast<int32_t>(0.062500f * 65536.0f) ? 3.292243417f : 3.638586634f;
                    else
                        return x > static_cast<int32_t>(0.031250f * 65536.0f) ? 3.985045009f : 4.331560985f;
                } else {
                    if (x > static_cast<int32_t>(0.011049f * 65536.0f))
                        return x > static_cast<int32_t>(0.015625f * 65536.0f) ? 4.678105767f : 5.024664952f;
                    else
                        return 5.371231340f;
                }
            }
        } else {
            if (x > static_cast<int32_t>(0.000691f * 65536.0f)) {
                if (x > static_cast<int32_t>(0.001953f * 65536.0f)) {
                    if (x > static_cast<int32_t>(0.003906f * 65536.0f))
                        return x > static_cast<int32_t>(0.005524f * 65536.0f) ? 5.717801329f : 6.064373119f;
                    else
                        return x > static_cast<int32_t>(0.002762f * 65536.0f) ? 6.410945809f : 6.757518949f;
                } else {
                    if (x > static_cast<int32_t>(0.000977f * 65536.0f))
                        return x > static_cast<int32_t>(0.001381f * 65536.0f) ? 7.104092314f : 7.450665792f;
                    else
                        return 7.797239326f;
                }
            } else {
                if (x > static_cast<int32_t>(0.000173f * 65536.0f)) {
                    if (x > static_cast<int32_t>(0.000345f * 65536.0f))
                        return x > static_cast<int32_t>(0.000488f * 65536.0f) ? 8.143812888f : 8.490386464f;
                    else
                        return x > static_cast<int32_t>(0.000244f * 65536.0f) ? 8.836960047f : 9.183533634f;
                } else {
                    if (x > static_cast<int32_t>(0.000086f * 65536.0f))
                        return x > static_cast<int32_t>(0.000122f * 65536.0f) ? 9.530107222f : 9.876680812f;
                    else
                        return 10.000000000f;
                }
            }
        }
    }
    // Fallthrough for out-of-range or negative input (saturate to maximum)
    return 10.0f;
}

// ---------------------------------------------------------------------------
// 4. Golden-prime deinterleaver  (codec2/src/gp_interleaver.c)
//
//    Hardcoded for N=56, b=37 (the HRA_56_56 / RADE EOO parameters).
//    Mapping: out[i] = in[(37*i) % 56]
// ---------------------------------------------------------------------------
static void gp_deinterleave_56(EooComp out[56], const EooComp in[56])
{
    for (int i = 0; i < 56; i++)
        out[i] = in[(37 * i) % 56];
}

// ---------------------------------------------------------------------------
// 5. QPSK soft demodulator  (codec2/src/mpdecode_core.c)
//
//    QPSK constellation (S_matrix in mpdecode_core.c):
//      index 0 = (1, 0), index 1 = (0, 1),
//      index 2 = (0,-1), index 3 = (-1,0)
// ---------------------------------------------------------------------------
static const EooComp kQpsk[4] = {
    {1.0f, 0.0f}, {0.0f, 1.0f}, {0.0f, -1.0f}, {-1.0f, 0.0f}
};

// Linear-log-MAP approximation (max_star0 in mpdecode_core.c)
static float eoo_max_star0(float d1, float d2)
{
    static const float A = -0.24904163195436f;
    static const float T =  2.50681740420944f;
    const float diff = d2 - d1;
    if      (diff >  T) return d2;
    else if (diff < -T) return d1;
    else if (diff >  0) return d2 + A * (diff - T);
    else                return d1 - A * (diff + T);
}

// Compute QPSK symbol log-likelihoods  (Demod2D in mpdecode_core.c)
//   sym_ll: output array of nsyms*4 values
static void eoo_demod2d(float sym_ll[], const EooComp r[],
                         const float fading[], float mean_amp,
                         float EsNo, int nsyms)
{
    for (int i = 0; i < nsyms; i++) {
        for (int j = 0; j < 4; j++) {
            const float sr = fading[i] * kQpsk[j].real / mean_amp;
            const float si = fading[i] * kQpsk[j].imag / mean_amp;
            const float er = r[i].real / mean_amp - sr;
            const float ei = r[i].imag / mean_amp - si;
            sym_ll[i * 4 + j] = -EsNo * (er * er + ei * ei);
        }
    }
}

// Soft-output MAP: symbol likelihoods → per-bit likelihoods  (Somap in mpdecode_core.c)
//   M=4, bps=2; bit 0 is MSB, bit 1 is LSB.
static void eoo_somap(float bit_ll[], const float sym_ll[], int nsyms)
{
    for (int n = 0; n < nsyms; n++) {
        float num0 = -1e6f, num1 = -1e6f;
        float den0 = -1e6f, den1 = -1e6f;
        for (int i = 0; i < 4; i++) {
            const float m = sym_ll[n * 4 + i];
            if (i & 2) num0 = eoo_max_star0(num0, m); else den0 = eoo_max_star0(den0, m);
            if (i & 1) num1 = eoo_max_star0(num1, m); else den1 = eoo_max_star0(den1, m);
        }
        bit_ll[2 * n + 0] = num0 - den0;
        bit_ll[2 * n + 1] = num1 - den1;
    }
}

// Convert QPSK symbols → LLRs  (symbols_to_llrs in mpdecode_core.c)
//   Output: nsyms*2 LLRs (positive = bit-0 more likely).
//   Fixed for N_LDPC_SYMS=56: sym_ll is 56*4=224, bit_ll is 56*2=112.
static void eoo_symbols_to_llrs(float llr[], const EooComp syms[],
                                  const float amps[], float EsNo,
                                  float mean_amp, int nsyms)
{
    float sym_ll[56 * 4];   // 224 floats – sized for HRA_56_56 (nsyms == 56)
    float bit_ll[56 * 2];   // 112 floats
    eoo_demod2d(sym_ll, syms, amps, mean_amp, EsNo, nsyms);
    eoo_somap(bit_ll, sym_ll, nsyms);
    for (int i = 0; i < nsyms * 2; i++)
        llr[i] = -bit_ll[i];
}

// ---------------------------------------------------------------------------
// 6. HRA_56_56 LDPC sum-product decoder  (codec2/src/mpdecode_core.c)
//
//    Hardcoded for HRA_56_56: H1=1, shift=0, dec_type=0 (uses phi0).
// ---------------------------------------------------------------------------

struct EooCSubNode { uint16_t index, socket; float message; };
struct EooVSubNode { uint16_t index, socket; float message; uint8_t sign; };
struct EooCNode    { int degree; EooCSubNode *subs; };
struct EooVNode    { int degree; float initial_value; EooVSubNode *subs; };

// Wire up the factor graph.  Corresponds to init_c_v_nodes() in mpdecode_core.c
// with the H1=1, shift=0 branch selected for HRA_56_56.
static void eoo_init_graph(EooCNode c_nodes[], EooVNode v_nodes[], float input[])
{
    const int NP  = kNumParityBits;   // 56
    const int CL  = kCodeLength;      // 112
    const int MRW = kMaxRowWeight;    // 3
    const int MCW = kMaxColWeight;    // 3
    const int NRC = kNumRowsHcols;    // 56

    // --- c-node degrees (H1=1, shift=0) ---
    for (int i = 0; i < NP; i++) {
        int cnt = 0;
        for (int j = 0; j < MRW; j++)
            if (kHra5656Rows[i + j * NP] > 0) cnt++;
        // c_nodes[0] gets one extra connection (to parity v-node 0 only),
        // all others get two extra (to parity v-nodes i-1 and i).
        c_nodes[i].degree = (i == 0) ? cnt + 1 : cnt + 2;
    }

    // --- allocate and populate c-node sub-nodes ---
    for (int i = 0; i < NP; i++) {
        c_nodes[i].subs = static_cast<EooCSubNode*>(
            calloc(c_nodes[i].degree, sizeof(EooCSubNode)));
        assert(c_nodes[i].subs);

        // First (degree-2) sub-nodes come from H_rows
        for (int j = 0; j < c_nodes[i].degree - 2; j++)
            c_nodes[i].subs[j].index = kHra5656Rows[i + j * NP] - 1;

        // Second-to-last: H_rows for i=0, otherwise systematic parity v-node i-1
        const int j1 = c_nodes[i].degree - 2;
        c_nodes[i].subs[j1].index = (i == 0)
            ? kHra5656Rows[i + j1 * NP] - 1
            : static_cast<uint16_t>((CL - NP) + i - 1);

        // Last: parity v-node i
        const int j2 = c_nodes[i].degree - 1;
        c_nodes[i].subs[j2].index = static_cast<uint16_t>((CL - NP) + i);
    }

    // --- v-node degrees ---
    // Data v-nodes (0..55): degree from H_cols
    for (int i = 0; i < CL - NP; i++) {
        int cnt = 0;
        for (int j = 0; j < MCW; j++)
            if (kHra5656Cols[i + j * NRC] > 0) cnt++;
        v_nodes[i].degree = cnt;
    }
    // Parity v-nodes (56..111): H1=1 ladder structure
    for (int i = CL - NP; i < CL; i++)
        v_nodes[i].degree = (i != CL - 1) ? 2 : 1;

    // --- allocate and populate v-node sub-nodes ---
    for (int i = 0; i < CL; i++) {
        v_nodes[i].subs = static_cast<EooVSubNode*>(
            calloc(v_nodes[i].degree, sizeof(EooVSubNode)));
        assert(v_nodes[i].subs);
        v_nodes[i].initial_value = input[i];

        int cnt = 0;
        for (int j = 0; j < v_nodes[i].degree; j++) {
            if (i >= CL - NP) {
                // Parity v-node: connects to adjacent c-nodes
                v_nodes[i].subs[j].index =
                    static_cast<uint16_t>(i - (CL - NP) + cnt++);
            } else {
                // Data v-node: from H_cols
                v_nodes[i].subs[j].index = kHra5656Cols[i + j * NRC] - 1;
            }

            // Find socket in connected c-node
            for (int ci = 0; ci < c_nodes[v_nodes[i].subs[j].index].degree; ci++) {
                if (c_nodes[v_nodes[i].subs[j].index].subs[ci].index ==
                        static_cast<uint16_t>(i)) {
                    v_nodes[i].subs[j].socket = static_cast<uint16_t>(ci);
                    break;
                }
            }

            // Initialise message with phi0(|LLR|) since dec_type=0
            v_nodes[i].subs[j].message = eoo_phi0(std::fabs(input[i]));
            v_nodes[i].subs[j].sign    = (input[i] < 0.0f) ? 1u : 0u;
        }
    }

    // --- finish c-node socket wiring ---
    for (int i = 0; i < NP; i++) {
        for (int j = 0; j < c_nodes[i].degree; j++) {
            const uint16_t vi = c_nodes[i].subs[j].index;
            for (int k = 0; k < v_nodes[vi].degree; k++) {
                if (v_nodes[vi].subs[k].index == static_cast<uint16_t>(i)) {
                    c_nodes[i].subs[j].socket = static_cast<uint16_t>(k);
                    break;
                }
            }
        }
    }
}

// Sum-product belief-propagation  (SumProduct in mpdecode_core.c).
// Returns iteration count; *parityCheckCount is updated each pass.
static int eoo_sum_product(int *parityCheckCount, uint8_t out_char[],
                            EooCNode c_nodes[], EooVNode v_nodes[])
{
    const int NP = kNumParityBits;   // 56
    const int CL = kCodeLength;      // 112

    uint8_t *decoded = static_cast<uint8_t*>(calloc(CL, sizeof(uint8_t)));
    assert(decoded);

    int result = kMaxIter;
    for (int iter = 0; iter < kMaxIter; iter++) {
        std::memset(decoded, 0, CL);

        // Update r: c-node messages
        int ssum = 0;
        for (int j = 0; j < NP; j++) {
            const EooCSubNode *cs0 = &c_nodes[j].subs[0];
            int   sign    = v_nodes[cs0->index].subs[cs0->socket].sign;
            float phi_sum = v_nodes[cs0->index].subs[cs0->socket].message;

            for (int i = 1; i < c_nodes[j].degree; i++) {
                const EooCSubNode *cp = &c_nodes[j].subs[i];
                const EooVSubNode *vp = &v_nodes[cp->index].subs[cp->socket];
                phi_sum += vp->message;
                sign    ^= vp->sign;
            }
            if (sign == 0) ssum++;

            for (int i = 0; i < c_nodes[j].degree; i++) {
                EooCSubNode *cp = &c_nodes[j].subs[i];
                EooVSubNode *vp = &v_nodes[cp->index].subs[cp->socket];
                const float extrinsic = phi_sum - vp->message;
                cp->message = (sign ^ vp->sign)
                    ? -eoo_phi0(extrinsic)
                    :  eoo_phi0(extrinsic);
            }
        }

        // Update q: v-node messages and hard decisions
        for (int i = 0; i < CL; i++) {
            float Qi = v_nodes[i].initial_value;
            for (int j = 0; j < v_nodes[i].degree; j++) {
                EooVSubNode *vp = &v_nodes[i].subs[j];
                Qi += c_nodes[vp->index].subs[vp->socket].message;
            }
            if (Qi < 0.0f) decoded[i] = 1;

            for (int j = 0; j < v_nodes[i].degree; j++) {
                EooVSubNode *vp = &v_nodes[i].subs[j];
                const float ts = Qi - c_nodes[vp->index].subs[vp->socket].message;
                vp->message = eoo_phi0(std::fabs(ts));
                vp->sign    = (ts > 0.0f) ? 0u : 1u;
            }
        }

        *parityCheckCount = ssum;
        if (ssum == NP) { result = iter + 1; break; }
    }

    std::memcpy(out_char, decoded, CL);
    free(decoded);
    return result;
}

// Convenience wrapper: allocates graph, runs decoder, frees graph.
// Matches the codec2 run_ldpc_decoder() interface for HRA_56_56.
static int eoo_run_ldpc_decoder(uint8_t out_char[], float input[],
                                  int *parityCheckCount)
{
    const int NP = kNumParityBits;
    const int CL = kCodeLength;

    EooCNode *c_nodes = static_cast<EooCNode*>(calloc(NP, sizeof(EooCNode)));
    EooVNode *v_nodes = static_cast<EooVNode*>(calloc(CL, sizeof(EooVNode)));
    assert(c_nodes && v_nodes);

    eoo_init_graph(c_nodes, v_nodes, input);

    const int iter = eoo_sum_product(parityCheckCount, out_char, c_nodes, v_nodes);

    for (int i = 0; i < NP; i++) free(c_nodes[i].subs);
    free(c_nodes);
    for (int i = 0; i < CL; i++) free(v_nodes[i].subs);
    free(v_nodes);

    return iter;
}

} // anonymous namespace


// ============================================================================
// EooCallsignDecoder
// ============================================================================

/**
 * Decodes the callsign carried in a RADE End-of-Over symbol buffer.
 *
 * The EOO buffer is the float array filled by rade_rx() into its eooOut
 * parameter.  Interleaved I/Q pairs represent QPSK symbols; the first 56
 * symbols carry an HRA_56_56 LDPC-encoded payload of:
 *   - 1 CRC-8 byte  (bits 0–7 of the 56 info bits)
 *   - up to 8 callsign characters encoded in 6 bits each (bits 8–55)
 *
 * Callsign character set (6-bit OTA values → ASCII, from rade_text.c):
 *   OTA  0        → end of callsign (null terminator)
 *   OTA  1– 9    → ASCII 38–46  (&'()*+,-.)
 *   OTA 10–19    → ASCII '0'–'9'
 *   OTA 20–46    → ASCII 'A'–'Z'
 */
class EooCallsignDecoder
{
public:
    /**
     * Attempt to decode the callsign from an EOO symbol buffer.
     *
     * @param syms      Float array from rade_rx() eooOut: interleaved I, Q
     *                  pairs, so syms[2*i] = real part, syms[2*i+1] = imag
     *                  part of symbol i.
     * @param symSize   Number of complex symbols = rade_n_eoo_bits(dv) / 2.
     * @param callsign  Set to the decoded callsign string on success.
     * @return          true if the LDPC BER estimate is < 0.2 and CRC-8 passes.
     */
    bool decode(const float *syms, int symSize, std::string &callsign) const
    {
        // --- Step 1: deinterleave the first 56 QPSK symbols ---
        EooComp pending[56];
        gp_deinterleave_56(pending, reinterpret_cast<const EooComp*>(syms));

        // --- Step 2: RMS over the 56 deinterleaved symbols ----------------
        //   The denominator is the full symSize (matches rade_text_rx behaviour:
        //   only the LDPC symbols contribute to the numerator, but the total
        //   symbol count is used to normalise).
        float rms = 0.0f;
        for (int i = 0; i < 56; i++)
            rms += pending[i].real * pending[i].real
                 + pending[i].imag * pending[i].imag;
        rms = std::sqrt(rms / static_cast<float>(symSize));

        // Guard against zero-amplitude input (no signal → can't decode)
        if (rms < 1e-10f) return false;

        // --- Step 3: soft-decision LDPC decode ----------------------------
        float amps[56];
        for (int i = 0; i < 56; i++) amps[i] = rms;

        float   llr[112];
        uint8_t decoded[112] = {};
        int     parityChecks = 0;

        eoo_symbols_to_llrs(llr, pending, amps, /*EsNo=*/3.0f, rms, 56);
        eoo_run_ldpc_decoder(decoded, llr, &parityChecks);

        // --- Step 4: BER gate (threshold 0.2, matching rade_text_rx) ------
        const float ber = static_cast<float>(kNumParityBits - parityChecks)
                        / static_cast<float>(kNumParityBits);
        if (ber >= 0.2f) return false;

        // --- Step 5: unpack 56 info bits into 9 raw bytes -----------------
        //   rawStr[0]    = CRC-8  (bits 0–7, standard 8-bit packing)
        //   rawStr[1..8] = OTA-encoded callsign chars (bits 8–55, 6 bits each)
        char rawStr[9] = {};
        for (int b = 0; b < 8; b++)
            if (decoded[b]) rawStr[0] |= static_cast<char>(1 << b);
        for (int b = 8; b < 56; b++) {
            const int off = b - 8;
            if (decoded[b])
                rawStr[1 + off / 6] |= static_cast<char>(1 << (off % 6));
        }

        // --- Step 6: CRC-8 check (over OTA bytes, not ASCII) --------------
        const uint8_t rxCrc   = static_cast<uint8_t>(rawStr[0]);
        const uint8_t calcCrc = crc8(rawStr + 1, 8);
        if (rxCrc != calcCrc) return false;

        // --- Step 7: decode OTA values to ASCII callsign ------------------
        callsign = otaToAscii(rawStr + 1, 8);
        return true;
    }

private:
    // CRC-8 with generator 0x1D  (calculateCRC8_ in rade_text.c).
    // Stops at the first null byte.
    static uint8_t crc8(const char *data, int maxLen)
    {
        const uint8_t gen = 0x1D;
        uint8_t crc = 0x00;
        for (int i = 0; i < maxLen; i++) {
            const uint8_t ch = static_cast<uint8_t>(data[i]);
            if (ch == 0) break;
            uint8_t acc = crc ^ ch;
            for (int b = 0; b < 8; b++)
                acc = (acc & 0x80)
                    ? static_cast<uint8_t>((acc << 1) ^ gen)
                    : static_cast<uint8_t>(acc << 1);
            crc = acc;
        }
        return crc;
    }

    // 6-bit OTA value → ASCII  (convert_ota_string_to_callsign_ in rade_text.c)
    static std::string otaToAscii(const char *ota, int maxLen)
    {
        std::string out;
        out.reserve(maxLen);
        for (int i = 0; i < maxLen; i++) {
            const uint8_t c = static_cast<uint8_t>(ota[i]);
            if      (c == 0)              break;
            else if (c >=  1 && c <=  9)  out += static_cast<char>(c + 37);
            else if (c >= 10 && c <= 19)  out += static_cast<char>(c - 10 + '0');
            else if (c >= 20 && c <= 46)  out += static_cast<char>(c - 20 + 'A');
        }
        return out;
    }
};
